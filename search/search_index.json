{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home This is a collection of my notes from a Gradle Fundamentals course. These are raw notes and I may or may not be cleaning them up in the future. It is meant as a jumping point to give people things to go off and research on their own and for me to remember what I learned. Note: I have a lot of experience with Maven, but hardly any with Gradle, so you will notice I reference Maven a bit in these notes. This is just for me to draw similarities between the two tools so I can understand Gradle better. If you don't have experience with Maven, just ignore the references as they don't really matter.","title":"Home"},{"location":"#home","text":"This is a collection of my notes from a Gradle Fundamentals course. These are raw notes and I may or may not be cleaning them up in the future. It is meant as a jumping point to give people things to go off and research on their own and for me to remember what I learned. Note: I have a lot of experience with Maven, but hardly any with Gradle, so you will notice I reference Maven a bit in these notes. This is just for me to draw similarities between the two tools so I can understand Gradle better. If you don't have experience with Maven, just ignore the references as they don't really matter.","title":"Home"},{"location":"sections/1-intro/","text":"What is Gradle? Applications can be pretty complicated and involve lots of files and artifacts. They may contain java src, java byte code, xml files, etc. So building a deployable application can be pretty difficult. Gradle's purpose is to build and deploy the application once we've written it. Gradle is a framework for building applications and managing dependencies. Source code --> Gradle --> Deployable artifacts. What are dependencies? Third party jars Internal/ Proprietary artifacts Gradle uses Groovy instead of a declarative XML language (like Ant and Maven use). 6 Key features of Gradle: Build File Human and machine readable file Declarative and programmatic Uses DSL and Groovy (or Kotlin if you want) Default name is build.gradle Graph of the Tasks Tasks are the detailed build steps Gradle parses the build.gradle file to get the tasks Creates a DAG (directed acryilic graph) a set of tasks that only go in one direction (acyclic) Gradle executes the tasks In the order that it has figured out that they have to be executed Each task gets some input and produces some output to be used by the next task Manages dependencies Dependencies are jars outside the code May be transitive dependencies (additional dependencies internal to that jar) Can get the specific version of the dependency Uses repositories Storehouses of external dependencies Out on the Internet In our corp artifactory Self-updating Gradle can retrieve new versions of gradle itself auto-retrieval of new dependencies that we define","title":"Section 1: Introduction"},{"location":"sections/1-intro/#what-is-gradle","text":"Applications can be pretty complicated and involve lots of files and artifacts. They may contain java src, java byte code, xml files, etc. So building a deployable application can be pretty difficult. Gradle's purpose is to build and deploy the application once we've written it. Gradle is a framework for building applications and managing dependencies. Source code --> Gradle --> Deployable artifacts. What are dependencies? Third party jars Internal/ Proprietary artifacts Gradle uses Groovy instead of a declarative XML language (like Ant and Maven use). 6 Key features of Gradle: Build File Human and machine readable file Declarative and programmatic Uses DSL and Groovy (or Kotlin if you want) Default name is build.gradle Graph of the Tasks Tasks are the detailed build steps Gradle parses the build.gradle file to get the tasks Creates a DAG (directed acryilic graph) a set of tasks that only go in one direction (acyclic) Gradle executes the tasks In the order that it has figured out that they have to be executed Each task gets some input and produces some output to be used by the next task Manages dependencies Dependencies are jars outside the code May be transitive dependencies (additional dependencies internal to that jar) Can get the specific version of the dependency Uses repositories Storehouses of external dependencies Out on the Internet In our corp artifactory Self-updating Gradle can retrieve new versions of gradle itself auto-retrieval of new dependencies that we define","title":"What is Gradle?"},{"location":"sections/2-build-java-project-with-gradle/","text":"Build a Java Project with Gradle Go to IntelliJ and create a new project with Gradle. The build.gradle file will look like this: plugins { id 'java' } group 'org.example' version '1.0-SNAPSHOT' repositories { mavenCentral() } dependencies { testCompile group: 'junit', name: 'junit', version: '4.12' } Group and Version follow the same concepts as Maven. The artifact name is sotred in the gradle.settings file instead of with the group and version tags. Repositories is pointing to Maven Central, you can also point to other repos, including corp artifactory. Dependencies has junit on the testCompile group. I found a better example of a build.gradle file using the spring initializer. plugins { id 'org.springframework.boot' version '2.4.1' id 'io.spring.dependency-management' version '1.0.10.RELEASE' id 'java' } group = 'com.example' version = '0.0.1-SNAPSHOT' sourceCompatibility = '8' configurations { compileOnly { extendsFrom annotationProcessor } } repositories { mavenCentral() } dependencies { implementation 'org.springframework.boot:spring-boot-starter' compileOnly 'org.projectlombok:lombok' annotationProcessor 'org.projectlombok:lombok' testImplementation 'org.springframework.boot:spring-boot-starter-test' } test { useJUnitPlatform() } To build gradle use the following command: gradle build Learning Groovy for Gradle Examining Java to Groovy: System.out.println(); becomes just println() There's no need for semicolon at the end of statements. If there's one arg in a method call, you don't need to have parentheses. It's still compiled down to byte code, the syntax is just more simple. class MyClass { void doSomething(Closure closure) { closure.call() } } myObject = new MyClass() myObject.doSomething{ println new Date() } With closures in Groovy (and Java 8+), you can define a method body at run time to be called and executed. The Gradle Project Object Model What is the POM? * Is a Java object built by Gradle * Represents the \"things\" in our application * Is used by Gradle to build projects * Is modifiable by developers Objects in the POM: * Project * One-to-one relationship with build.gradle * Assigned to a \"project\" reference variable * Task * Project is a collection of tasks (compiler, create jar file, etc.) * Task is a collection of actions * Actions are functions performed by Gradle * Actions list tasks for project The build.gradle file modifies the Project Object project.sourceCompatibility = 1.8 project.dependencies {} You don't have to specify the project object, but you can. Run the following command to see the project properties available: gradle properties You can also view available properties at https://docs.gradle.org/current/javadoc/org/gradle/api/Project.html To view available tasks run the following command: gradle tasks","title":"Section 2: Build a Java Project with Gradle"},{"location":"sections/2-build-java-project-with-gradle/#build-a-java-project-with-gradle","text":"Go to IntelliJ and create a new project with Gradle. The build.gradle file will look like this: plugins { id 'java' } group 'org.example' version '1.0-SNAPSHOT' repositories { mavenCentral() } dependencies { testCompile group: 'junit', name: 'junit', version: '4.12' } Group and Version follow the same concepts as Maven. The artifact name is sotred in the gradle.settings file instead of with the group and version tags. Repositories is pointing to Maven Central, you can also point to other repos, including corp artifactory. Dependencies has junit on the testCompile group. I found a better example of a build.gradle file using the spring initializer. plugins { id 'org.springframework.boot' version '2.4.1' id 'io.spring.dependency-management' version '1.0.10.RELEASE' id 'java' } group = 'com.example' version = '0.0.1-SNAPSHOT' sourceCompatibility = '8' configurations { compileOnly { extendsFrom annotationProcessor } } repositories { mavenCentral() } dependencies { implementation 'org.springframework.boot:spring-boot-starter' compileOnly 'org.projectlombok:lombok' annotationProcessor 'org.projectlombok:lombok' testImplementation 'org.springframework.boot:spring-boot-starter-test' } test { useJUnitPlatform() } To build gradle use the following command: gradle build","title":"Build a Java Project with Gradle"},{"location":"sections/2-build-java-project-with-gradle/#learning-groovy-for-gradle","text":"Examining Java to Groovy: System.out.println(); becomes just println() There's no need for semicolon at the end of statements. If there's one arg in a method call, you don't need to have parentheses. It's still compiled down to byte code, the syntax is just more simple. class MyClass { void doSomething(Closure closure) { closure.call() } } myObject = new MyClass() myObject.doSomething{ println new Date() } With closures in Groovy (and Java 8+), you can define a method body at run time to be called and executed.","title":"Learning Groovy for Gradle"},{"location":"sections/2-build-java-project-with-gradle/#the-gradle-project-object-model","text":"What is the POM? * Is a Java object built by Gradle * Represents the \"things\" in our application * Is used by Gradle to build projects * Is modifiable by developers Objects in the POM: * Project * One-to-one relationship with build.gradle * Assigned to a \"project\" reference variable * Task * Project is a collection of tasks (compiler, create jar file, etc.) * Task is a collection of actions * Actions are functions performed by Gradle * Actions list tasks for project The build.gradle file modifies the Project Object project.sourceCompatibility = 1.8 project.dependencies {} You don't have to specify the project object, but you can. Run the following command to see the project properties available: gradle properties You can also view available properties at https://docs.gradle.org/current/javadoc/org/gradle/api/Project.html To view available tasks run the following command: gradle tasks","title":"The Gradle Project Object Model"},{"location":"sections/3-dependencies/","text":"Dependencies Run gradle projects to see a list of dependencies and other info about a project. Run gradle dependencies to view all dependencies. Run gradle dependencies --configuration compile to view all dependencies in the compile configuration. Run gradle dependencies --configuration testCompile to view all dependencies in the testCompile configuration (will also include all regular compile dependencies). This will also bring in transitive dependencies in a basic starter project. There is a way to specify version versions of transitive dependencies, which the instructor will explain later. Add apply plugin: 'project-report to gradle.build and then run gradle htmlDependencyReport to create a report file that lists the dependencies. Creating Library Modules Steps: * Define a new module * Code the module * Assign the dependency for the module * Extract the JSON display code into a separate module Add a new module to IntelliJ and take a look at the settings.gradle file in the root directory. You will notice that the new module has been added as follows: include 'project-name' If you want to pull in the new module (library) into another module or the root project if you have one, you can add it as a dependency as follows: project.dependencies { compile project(':project-name') }","title":"Section 3: Dependencies"},{"location":"sections/3-dependencies/#dependencies","text":"Run gradle projects to see a list of dependencies and other info about a project. Run gradle dependencies to view all dependencies. Run gradle dependencies --configuration compile to view all dependencies in the compile configuration. Run gradle dependencies --configuration testCompile to view all dependencies in the testCompile configuration (will also include all regular compile dependencies). This will also bring in transitive dependencies in a basic starter project. There is a way to specify version versions of transitive dependencies, which the instructor will explain later. Add apply plugin: 'project-report to gradle.build and then run gradle htmlDependencyReport to create a report file that lists the dependencies.","title":"Dependencies"},{"location":"sections/3-dependencies/#creating-library-modules","text":"Steps: * Define a new module * Code the module * Assign the dependency for the module * Extract the JSON display code into a separate module Add a new module to IntelliJ and take a look at the settings.gradle file in the root directory. You will notice that the new module has been added as follows: include 'project-name' If you want to pull in the new module (library) into another module or the root project if you have one, you can add it as a dependency as follows: project.dependencies { compile project(':project-name') }","title":"Creating Library Modules"},{"location":"sections/4-gradle-project-structure/","text":"Gradle Project Structure List of important files: settings.gradle The most important gradle file defines the root project name can include other libraries buiild.gradle Defines artifact info (groupa and version) apply plugins (Java plugin) define the source compatibility declare repositories to use declare dependencies src normal java conventional dir structure src main java packages classes resources test java ... test resources gradle directory known as the gradle wrapper provides a lightweight version of gradle to make sure that all devs are using the same version of gradle to work together. Gradle Build Directory This is where the final artifact is saved. Run gradle -q clean to clean out the build directory. The Gradle Wrapper The gradle wrapper is a thin layer around gradle. It checks that gradle is installed properly. gradlew is for unix gradle.bat is for Windows","title":"Section 4: Gradle Project Structure"},{"location":"sections/4-gradle-project-structure/#gradle-project-structure","text":"List of important files: settings.gradle The most important gradle file defines the root project name can include other libraries buiild.gradle Defines artifact info (groupa and version) apply plugins (Java plugin) define the source compatibility declare repositories to use declare dependencies src normal java conventional dir structure src main java packages classes resources test java ... test resources gradle directory known as the gradle wrapper provides a lightweight version of gradle to make sure that all devs are using the same version of gradle to work together.","title":"Gradle Project Structure"},{"location":"sections/4-gradle-project-structure/#gradle-build-directory","text":"This is where the final artifact is saved. Run gradle -q clean to clean out the build directory.","title":"Gradle Build Directory"},{"location":"sections/4-gradle-project-structure/#the-gradle-wrapper","text":"The gradle wrapper is a thin layer around gradle. It checks that gradle is installed properly. gradlew is for unix gradle.bat is for Windows","title":"The Gradle Wrapper"},{"location":"sections/5-gradle-tasks/","text":"Gradle Tasks Functions performed by gradle Consists of one of more actions Tell gradle what to do Can depend on other tasks e.g. gradle build To view tasks run gradle tasks Gradle View Tool Provides an alternate way to running Gradle tasks Has its own GUI Is useful when you are first learning Gradle Is available in IntelliJ just the same as Maven Create a New Gradle Task Example task that prints the current date: task showDate { dependsOn build group = 'my tasks' description = \"Show current date\" doLast { println 'Current Date: ' + new Date() } } Run gradle showDate in terminal to run the task. To make it depend on another task, add the dependsOn var. This means that build needs to run before showTask will run, meaning that gradle showDate will run the build and then showDate tasks. group assigns the task to a group and description offers a description in the task view. If you don't assign a task to a group, it won't show up when running gradle tasks . To show the task you will either have to run gradle tasks --all or just add the task to a group. Extend Existing Tasks class ShowDate extends DefaultTask { String dataMessage = \"Date is: \" @TaskAction void showDate() { println dateMessage + new Date() } } task showDate(type: ShowDate) In the code above, we define a class that extends the DefaultTask class. We define what we want the task to do in a method annotated with @TaskAction and pull it all into the build.gradle file with a task. Other methods available in the Task interface that DefaultTask implements: configure(Closure configureClosure) deleteAllActions() doFirst(Closure action) doLast(Closure action) You can override an extending task. An example would be: task customShowDate(type: ShowDate) { dateMessage = \"Custom time is: \" } Creating Gradle Plugins Reasons for creating a plugin: * To stop from repeating yourself * Allows resuse within project and enterprise buildscript { dependencies { classpath files('module-name/build/libs/module-project-name-1.0-SNAPSHOT.jar') } } apply plugin: 'module-project-name-plugin' To run the plugin use gradle moduleName","title":"Section 5: Gradle Tasks"},{"location":"sections/5-gradle-tasks/#gradle-tasks","text":"Functions performed by gradle Consists of one of more actions Tell gradle what to do Can depend on other tasks e.g. gradle build To view tasks run gradle tasks","title":"Gradle Tasks"},{"location":"sections/5-gradle-tasks/#gradle-view-tool","text":"Provides an alternate way to running Gradle tasks Has its own GUI Is useful when you are first learning Gradle Is available in IntelliJ just the same as Maven","title":"Gradle View Tool"},{"location":"sections/5-gradle-tasks/#create-a-new-gradle-task","text":"Example task that prints the current date: task showDate { dependsOn build group = 'my tasks' description = \"Show current date\" doLast { println 'Current Date: ' + new Date() } } Run gradle showDate in terminal to run the task. To make it depend on another task, add the dependsOn var. This means that build needs to run before showTask will run, meaning that gradle showDate will run the build and then showDate tasks. group assigns the task to a group and description offers a description in the task view. If you don't assign a task to a group, it won't show up when running gradle tasks . To show the task you will either have to run gradle tasks --all or just add the task to a group.","title":"Create a New Gradle Task"},{"location":"sections/5-gradle-tasks/#extend-existing-tasks","text":"class ShowDate extends DefaultTask { String dataMessage = \"Date is: \" @TaskAction void showDate() { println dateMessage + new Date() } } task showDate(type: ShowDate) In the code above, we define a class that extends the DefaultTask class. We define what we want the task to do in a method annotated with @TaskAction and pull it all into the build.gradle file with a task. Other methods available in the Task interface that DefaultTask implements: configure(Closure configureClosure) deleteAllActions() doFirst(Closure action) doLast(Closure action) You can override an extending task. An example would be: task customShowDate(type: ShowDate) { dateMessage = \"Custom time is: \" }","title":"Extend Existing Tasks"},{"location":"sections/5-gradle-tasks/#creating-gradle-plugins","text":"Reasons for creating a plugin: * To stop from repeating yourself * Allows resuse within project and enterprise buildscript { dependencies { classpath files('module-name/build/libs/module-project-name-1.0-SNAPSHOT.jar') } } apply plugin: 'module-project-name-plugin' To run the plugin use gradle moduleName","title":"Creating Gradle Plugins"},{"location":"sections/6-gradle-profile-and-cloud/","text":"Gradle Profile A gradle profile: Lets you report on the build highlighting performance Can be created any time you run a task Can be saved permanently to record a history of the build performance Use grade build --profile to run a build and enable the profile. Every time you run the build task with profile enabled, it will output a profile report which lists the name, duration and results of each task. Gradle Cloud Build Scan The cloud build scan: * a new capability * a set of build reports * saved to the cloud instead of the local machine Add the plugin to your plugins section: plugin { id 'com.gradle.build-scan' version '1.6' } Add the build scan itself: buildScan { licenseAgreementUrl = 'https://gradle.com/terms-of-service' licenseAgree = 'yes' } Run with gradle build --scan to publish the build scan to the cloud.","title":"Section 6: Gradle Profile and Cloud"},{"location":"sections/6-gradle-profile-and-cloud/#gradle-profile","text":"A gradle profile: Lets you report on the build highlighting performance Can be created any time you run a task Can be saved permanently to record a history of the build performance Use grade build --profile to run a build and enable the profile. Every time you run the build task with profile enabled, it will output a profile report which lists the name, duration and results of each task.","title":"Gradle Profile"},{"location":"sections/6-gradle-profile-and-cloud/#gradle-cloud-build-scan","text":"The cloud build scan: * a new capability * a set of build reports * saved to the cloud instead of the local machine Add the plugin to your plugins section: plugin { id 'com.gradle.build-scan' version '1.6' } Add the build scan itself: buildScan { licenseAgreementUrl = 'https://gradle.com/terms-of-service' licenseAgree = 'yes' } Run with gradle build --scan to publish the build scan to the cloud.","title":"Gradle Cloud Build Scan"}]}